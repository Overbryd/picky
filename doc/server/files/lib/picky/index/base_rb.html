<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>base.rb</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="../../../../css/reset.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="../../../../css/main.css" type="text/css" media="screen" />
    <script src="../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
</head>

<body>     
    <div class="banner">
        <h1>
            base.rb
        </h1>
        <ul class="files">
            <li>lib/picky/index/base.rb</li>
            <li>Last modified: Wed Apr 20 20:40:35 +1000 2011</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
    
    <div class="description">
        <h1>Picky Indexes</h1>
<p>
A Picky <a href="../../../../classes/Index.html">Index</a> defines
</p>
<ul>
<li>where its data comes from (a data source).

</li>
<li>how this data it is indexed.

</li>
<li>a number of categories that may or may not map directly to data categories.

</li>
</ul>
<h2>Howto</h2>
<p>
This is a step-by-step description on how to create an index.
</p>
<p>
Start by choosing an <tt>Index::Memory</tt> or an <tt>Index::Redis</tt>. In
the example, we will be using an in-memory index, <tt>Index::Memory</tt>.
</p>
<pre>
  books = Index::Memory.new(:books)
</pre>
<p>
That in itself won&#8217;t do much good, that&#8217;s why we add a data
source:
</p>
<pre>
  books = Index::Memory.new(:books) do
    source Sources::CSV.new(:title, :author, file: 'data/books.csv')
  end
</pre>
<p>
In the example, we use an explicit <tt>Sources::CSV</tt> of Picky. However,
anything that responds to <tt>each</tt>, and returns an object that answers
to <tt>id</tt>, works.
</p>
<p>
For example, a 3.0 ActiveRecord class:
</p>
<pre>
  books = Index::Memory.new(:books) do
    source Book.order('isbn ASC')
  end
</pre>
<p>
Now we know where the data comes from, but not, how to categorize it.
</p>
<p>
Let&#8217;s add a few categories:
</p>
<pre>
  books = Index::Memory.new(:books) do
    source   Book.order('isbn ASC')
    category :title
    category :author
    category :isbn
  end
</pre>
<p>
Categories offer quite a few options, see <tt><a
href="../../../../classes/Index/Base.html#M000027">Index::Base#category</a></tt>
for details.
</p>
<p>
After adding more options, it might look like this:
</p>
<pre>
  books = Index::Memory.new(:books) do
    source   Book.order('isbn ASC')
    category :title,
             partial: Partial::Substring.new(from: 1),
             similarity: Similarity::DoubleMetaphone.new(3),
             qualifiers: [:t, :title, :titulo]
    category :author,
             similarity: Similarity::Metaphone.new(2)
    category :isbn,
             partial: Partial::None.new,
             from: :legacy_isbn_name
  end
</pre>
<p>
For this to work, a <tt>Book</tt> should support methods <tt>title</tt>,
<tt>author</tt> and <tt>legacy_isbn_name</tt>.
</p>
<p>
If it uses <tt>String</tt> ids, use <tt>key_format</tt> to define a
formatting method:
</p>
<pre>
  books = Index::Memory.new(:books) do
    key_format :to_s
    source     Book.order('isbn ASC')
    category   :title
    category   :author
    category   :isbn
  end
</pre>
<p>
Finally, use the index for a <tt>Search</tt>:
</p>
<pre>
  route %r{^/media$} =&gt; Search.new(books, dvds, mp3s)
</pre>

    </div>
    

    

    
    

    
    

    

    

    
    <div class="sectiontitle">Classes and Modules</div>
    <ul>
        
        <li><span class="type">MODULE</span> <a href="../../../../classes/Index.html">Index</a></li>
        
    </ul>
    

    

    

    
</div>
    </div>
  </body>
</html>